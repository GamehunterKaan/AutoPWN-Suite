from dataclasses import dataclass
from os import makedirs
from os.path import exists
from time import sleep

from requests import get
import re
from requests.exceptions import ConnectionError

from modules.logger import banner
from modules.random_user_agent import random_user_agent
from modules.utils import get_terminal_width


@dataclass
class ExploitInfo:
    Severity: float
    severity_score: float
    Exploitability: float
    Platform: str
    PublishDate: str
    Type: str
    ExploitDBID: int
    Author: str
    Metasploit: bool
    Verified: bool
    Link: str


def GetExploitInfo(CVEID, log, max_exploits=10) -> list[ExploitInfo]:
    sleep(0.75)
    try:
        log.logger("debug", f"Fetching exploit information for CVE: {CVEID}")
        apidata = get(
            f"https://www.exploit-db.com/search?cve={CVEID}",
            headers={
                "X-Requested-With": "XMLHttpRequest",
                "User-Agent": next(random_user_agent(log)),
            },
        ).json()
        log.logger("debug", f"API data received: {apidata}")
    except ConnectionError:
        log.logger(
            "error",
            "Connection error raised while trying"
            + f" to fetch information about: {CVEID}",
        )
        return []
    except Exception as e:
        log.logger("error", f"An error occurred while parsing API response: {str(e)}")
        return []
    else:
        ExploitInfos = []
        for exploit in apidata["data"]:
            log.logger("debug", f"Processing exploit: {exploit}")
            Exploit = ExploitInfo(
                Severity=0.0,
                Exploitability=0.0,
                Platform=exploit["platform_id"],
                severity_score=0.0,
                PublishDate=exploit["date_published"],
                Type=exploit["type_id"],
                ExploitDBID=int(exploit["id"]),
                Author=exploit["author"]["name"],
                Metasploit=exploit["author"]["name"] == "Metasploit",
                Verified=exploit["verified"] == "1",
                Link=f"https://www.exploit-db.com/download/{exploit['id']}",
            )
            ExploitInfos.append(Exploit)

        log.logger("debug", f"ExploitInfos created: {ExploitInfos}")
        # Sort exploits by severity and exploitability
        ExploitInfos.sort(key=lambda x: (x.severity_score, x.Exploitability), reverse=True)
        
        # Limit the number of exploits based on max_vulns
        return ExploitInfos[:max_exploits]


def GetExploitContents(ExploitLink, log) -> tuple:
    sleep(0.75)
    user_agent = next(random_user_agent(log))
    try:
        log.logger("debug", f"Fetching exploit content from link: {ExploitLink}")
        apiresponse = get(
            ExploitLink,
            headers={
                "X-Requested-With": "XMLHttpRequest",
                "User-Agent": user_agent,
            },
        )
        content = apiresponse.content
        filename = apiresponse.headers["Content-Disposition"].lstrip(
            'attachment; filename="'
        )
        log.logger("debug", f"Exploit content fetched. Filename: {filename}")
    except ConnectionError:
        log.logger(
            "error", f"Connection error raised while trying to fetch: {ExploitLink}"
        )
        return None, None
    except KeyError:
        log.logger(
            "error", f"Unable to retrieve contents of {ExploitLink} with User-Agent {user_agent}"
        )
        return None, None
    else:
        return content, filename


def GetExploitAsFile(vulnerability, log, console, status, processed_cves, max_exploits=10) -> None:
    SoftwareName = vulnerability.title
    CVEs = vulnerability.CVEs
    term_width = get_terminal_width()
    if not SoftwareName or re.match(r'CVE-\d{4}-\d{4,7}', SoftwareName) or re.match(r'MS\d{2}-\d{3}', SoftwareName):
        SoftwareName = "CVE"

    log.logger("debug", f"Processing vulnerability: {SoftwareName}, CVEs: {CVEs}")

    if not exists("exploits"):
        makedirs("exploits", exist_ok=True)
        log.logger("debug", "Created directory: exploits")

    printed_software = []
    for CVE in CVEs:
        if CVE in processed_cves:
            log.logger("debug", f"Skipping already processed CVE: {CVE}")
            continue
        log.logger("debug", f"Fetching exploits for CVE: {CVE}")
        Exploits = GetExploitInfo(CVE, log, max_exploits)
        if len(Exploits) > 0:
            status.stop()
            if SoftwareName not in printed_software:
                console.print(f"┌─[yellow][ {SoftwareName} ][/yellow]\n│")
                printed_software.append(SoftwareName)

            console.print(f"│\n├─────┤ [red]{str(CVE)}[/red]\n│")

            # Sort exploits by severity and exploitability
            Exploits.sort(key=lambda x: (x.severity_score, x.Exploitability), reverse=False)
            
            # Display only the top N exploits
            for exploit in Exploits:
                log.logger("debug", f"Fetching contents for exploit: {exploit.Link}")
                content, filename = GetExploitContents(exploit.Link, log)
                if content is None:
                    log.logger("debug", f"Failed to fetch content for exploit: {exploit.Link}")
                    continue

                exploit_dir = f"exploits/{SoftwareName}/{CVE}"
                if SoftwareName == "CVE":
                    exploit_dir = f"exploits/CVE/{CVE}"
                if not exists(exploit_dir):
                    makedirs(exploit_dir, exist_ok=True)
                    log.logger("debug", f"Created directory: {exploit_dir}")

                file_path = f"{exploit_dir}/{filename}"
                with open(file_path, "wb") as exploitfile:
                    console.print(
                        f"├──────────# [white]{file_path}[/white]\n"
                        + f"│\t\t [cyan]Platform: [/cyan] {exploit.Platform}\n"
                        + f"│\t\t [cyan]Type: [/cyan] {exploit.Type}\n"
                        + f"│\t\t [cyan]Author: [/cyan] {exploit.Author}\n"
                        + f"│\t\t [cyan]Date: [/cyan] [bright_cyan]{exploit.PublishDate}[/bright_cyan]\n"
                        + f"│\t\t [cyan]Metasploit: [/cyan] {exploit.Metasploit}\n"
                        + f"│\t\t [cyan]Verified: [/cyan]{exploit.Verified}\n"
                        + f"│\t\t [cyan]Link: [/cyan] {exploit.Link}\n│"
                    )
                    exploitfile.write(content)
                    log.logger("debug", f"Written content to file: {file_path}")

        processed_cves.add(CVE)

    if SoftwareName in printed_software:
        console.print("└" + "─" * (term_width - 1) + "\n")


def GetExploitsFromArray(VulnsArray, log, console, console2, target=None) -> None:
    if target:
        log.logger("debug", f"Downloading exploits for target {target}")
    else:
        log.logger("debug", f"Downloading exploits...")

    log.logger("debug", f"Starting download of exploits for {target if target else 'all targets'}")

    processed_cves = set()

    with console2.status(
        "[red]Downloading exploits ...[/red]", spinner="bouncingBar"
    ) as status:
        for vulnerability in VulnsArray:
            status.start()
            status.update(
                f"[white]Downloading exploits for[/white] "
                + f"[red]{vulnerability.title}[/red] [white]...[/white]"
            )
            try:
                GetExploitAsFile(vulnerability, log, console, status, processed_cves, args.max_exploits)
            except KeyboardInterrupt:
                log.logger("warning", f"Skipping exploits for {vulnerability.title}")
