"""
Unit tests for the getexploits module.
"""
from unittest.mock import MagicMock, mock_open, patch, call

import pytest
from requests.exceptions import ConnectionError

from modules.getexploits import GetExploitInfo, ExploitInfo, GetExploitsFromArray, GetExploitContents, GetExploitAsFile


@pytest.mark.unit
class TestGetExploitInfo:
    """Tests for the GetExploitInfo function."""

    @pytest.fixture
    def mock_logger(self):
        """Fixture for a mocked logger."""
        return MagicMock()

    @patch("modules.getexploits.get")
    def test_get_exploit_info_success(self, mock_get, mock_logger):
        """
        Verify that exploit information is parsed correctly on a successful API call.
        """
        mock_response = MagicMock()
        mock_response.json.return_value = {
            "data": [
                {
                    "id": "12345",
                    "platform_id": "windows",
                    "date_published": "2023-10-27",
                    "type_id": "remote",
                    "author": {"name": "test_author"},
                    "verified": "1",
                }
            ]
        }
        mock_get.return_value = mock_response

        results = GetExploitInfo("CVE-2023-1234", mock_logger)

        assert len(results) == 1
        exploit = results[0]
        assert isinstance(exploit, ExploitInfo)
        assert exploit.ExploitDBID == 12345
        assert exploit.Platform == "windows"
        assert exploit.Author == "test_author"
        assert exploit.Verified is True
        assert exploit.Link == "https://www.exploit-db.com/download/12345"

    @patch("modules.getexploits.get", side_effect=ConnectionError)
    def test_get_exploit_info_connection_error(self, mock_get, mock_logger):
        """
        Verify that a connection error is handled gracefully.
        """
        cve_id = "CVE-2023-1234"
        results = GetExploitInfo(cve_id, mock_logger)

        assert results == []
        mock_logger.logger.assert_called_once_with(
            "error", f"Connection error raised while trying to fetch information about: {cve_id}"
        )

    @patch("modules.getexploits.get")
    def test_get_exploit_info_json_error(self, mock_get, mock_logger):
        """
        Verify that a JSON decoding error is handled gracefully.
        """
        mock_response = MagicMock()
        # Simulate a JSONDecodeError by having .json() raise an exception
        mock_response.json.side_effect = ValueError("Invalid JSON")
        mock_get.return_value = mock_response
        cve_id = "CVE-2023-JSON-ERROR"

        results = GetExploitInfo(cve_id, mock_logger)

        assert results == []
        mock_logger.logger.assert_called_once_with("error", "An error occured while parsing API response.")


@pytest.mark.unit
class TestGetExploitContents:
    """Tests for the GetExploitContents function."""

    @patch("modules.getexploits.get")
    def test_get_exploit_contents_success(self, mock_get):
        """Verify successful download and filename parsing."""
        mock_response = MagicMock()
        mock_response.content = b"exploit code"
        mock_response.headers = {"Content-Disposition": 'attachment; filename="12345.txt"'}
        mock_get.return_value = mock_response

        content, filename = GetExploitContents("http://example.com/exploit", MagicMock())

        assert content == b"exploit code"
        assert filename == '12345.txt"'

    @patch("modules.getexploits.get", side_effect=ConnectionError("Download failed"))
    def test_get_exploit_contents_connection_error(self, mock_get):
        """Verify a connection error is handled gracefully."""
        mock_log = MagicMock()
        link = "http://example.com/exploit"
        content, filename = GetExploitContents(link, mock_log)

        assert content is None
        assert filename is None
        mock_log.logger.assert_called_with("error", f"Connection error raised while trying to fetch: {link}")

    @patch("modules.getexploits.random_user_agent")
    @patch("modules.getexploits.get")
    def test_get_exploit_contents_missing_header(self, mock_get, mock_ua):
        """Verify it handles a response missing the Content-Disposition header."""
        mock_ua.return_value = iter(["Test-UA"])
        mock_response = MagicMock()
        mock_response.content = b"exploit code"
        mock_response.headers = {}  # No Content-Disposition header
        mock_get.return_value = mock_response
        mock_log = MagicMock()

        link = "http://example.com/exploit"
        content, filename = GetExploitContents(link, mock_log)
        assert content is None
        assert filename is None
        mock_log.logger.assert_called_with("error", f"Unable to retrieve contents of {link} Test-UA")


@pytest.mark.unit
class TestGetExploitAsFile:
    """Tests for the GetExploitAsFile function."""

    @pytest.fixture
    def mock_log_console_status(self):
        """Fixture for mocked log, console, and status objects."""
        return MagicMock(), MagicMock(), MagicMock()

    @patch("modules.getexploits.open", new_callable=mock_open)
    @patch("modules.getexploits.mkdir")
    @patch("modules.getexploits.exists", return_value=False)
    @patch("modules.getexploits.GetExploitContents")
    @patch("modules.getexploits.GetExploitInfo")
    def test_get_exploit_as_file_success(self, mock_get_info, mock_get_contents, mock_exists, mock_mkdir, mock_open_file, mock_log_console_status):
        """Verify an exploit is correctly downloaded and saved on the happy path."""
        mock_log, mock_console, mock_status = mock_log_console_status
        mock_vuln_software = MagicMock(title="TestSoftware", CVEs=["CVE-2023-1234"])
        mock_exploit_info = MagicMock(ExploitDBID=12345, Link="http://example.com/exploit")
        mock_get_info.return_value = [mock_exploit_info]
        mock_get_contents.return_value = (b"exploit_content", '12345.txt"')

        GetExploitAsFile(mock_vuln_software, mock_log, mock_console, mock_status)

        # Verify directories were created
        expected_dir_calls = [
            call("exploits"),
            call("exploits/TestSoftware"),
            call("exploits/TestSoftware/CVE-2023-1234"),
        ]
        mock_mkdir.assert_has_calls(expected_dir_calls)

        # Verify the file was opened and written to
        mock_open_file.assert_called_once_with('exploits/TestSoftware/CVE-2023-1234/12345.txt"', "wb")
        mock_open_file().write.assert_called_once_with(b"exploit_content")

    @patch("modules.getexploits.GetExploitInfo", return_value=[])
    def test_get_exploit_as_file_no_exploits(self, mock_get_info, mock_log_console_status):
        """Verify nothing is downloaded if GetExploitInfo returns no exploits."""
        mock_log, mock_console, mock_status = mock_log_console_status
        mock_vuln_software = MagicMock(title="TestSoftware", CVEs=["CVE-2023-NONE"])

        with patch("modules.getexploits.open") as mock_open_file:
            GetExploitAsFile(mock_vuln_software, mock_log, mock_console, mock_status)
            mock_open_file.assert_not_called()

    @patch("modules.getexploits.GetExploitContents", return_value=(None, None))
    @patch("modules.getexploits.GetExploitInfo")
    def test_get_exploit_as_file_no_content(self, mock_get_info, mock_get_contents, mock_log_console_status):
        """Verify nothing is downloaded if GetExploitContents returns None."""
        mock_log, mock_console, mock_status = mock_log_console_status
        mock_vuln_software = MagicMock(title="TestSoftware", CVEs=["CVE-2023-1234"])
        mock_exploit_info = MagicMock(Link="http://example.com/exploit")
        mock_get_info.return_value = [mock_exploit_info]

        with patch("modules.getexploits.open") as mock_open_file:
            GetExploitAsFile(mock_vuln_software, mock_log, mock_console, mock_status)
            mock_open_file.assert_not_called()


@pytest.mark.unit
class TestGetExploitsFromArray:
    """Tests for the GetExploitsFromArray function."""

    @pytest.fixture
    def mock_log_consoles(self):
        """Fixture for mocked log and console objects."""
        return MagicMock(), MagicMock(), MagicMock()

    @patch("modules.getexploits.open", new_callable=mock_open)
    @patch("modules.getexploits.mkdir")
    @patch("modules.getexploits.exists", return_value=False)
    @patch("modules.getexploits.GetExploitContents")
    @patch("modules.getexploits.GetExploitInfo")
    def test_exploit_found_and_downloaded(self, mock_get_info, mock_get_contents, mock_exists, mock_mkdir, mock_open_file, mock_log_consoles):
        """Verify an exploit is correctly downloaded and saved on the happy path."""
        mock_log, mock_console, mock_console2 = mock_log_consoles
        host = "192.168.1.1"

        # Mock the input data
        mock_vuln_software = MagicMock(title="TestSoftware", CVEs=["CVE-2023-1234"])
        mock_exploit_info = MagicMock(Link="http://example.com/exploit")
        mock_get_info.return_value = [mock_exploit_info]

        # Mock the downloaded content and filename
        mock_get_contents.return_value = (b"exploit_content", "12345.txt")

        GetExploitsFromArray([mock_vuln_software], mock_log, mock_console, mock_console2, host)

        # Verify directories were created
        expected_dir_calls = [
            call("exploits"),
            call("exploits/TestSoftware"),
            call("exploits/TestSoftware/CVE-2023-1234"),
        ]
        mock_mkdir.assert_has_calls(expected_dir_calls)

        # Verify the file was opened and written to
        mock_open_file.assert_called_once_with("exploits/TestSoftware/CVE-2023-1234/12345.txt", "wb")
        mock_open_file().write.assert_called_once_with(b"exploit_content")

    @patch("modules.getexploits.GetExploitInfo", return_value=[])
    def test_no_exploits_found(self, mock_get_info, mock_log_consoles):
        """Verify nothing happens if no exploits are found for a CVE."""
        mock_log, mock_console, mock_console2 = mock_log_consoles
        mock_vuln_software = MagicMock(CVEs=["CVE-2023-NONE"])

        GetExploitsFromArray([mock_vuln_software], mock_log, mock_console, mock_console2, "host")

        mock_log.logger.assert_not_called()

    @patch("modules.getexploits.get", side_effect=ConnectionError("Download failed"))
    @patch("modules.getexploits.GetExploitInfo")
    def test_download_connection_error(self, mock_get_info, mock_get, mock_log_consoles):
        """Verify a download connection error is handled gracefully."""
        mock_log, mock_console, mock_console2 = mock_log_consoles
        exploit_link = "http://example.com/exploit"
        mock_vuln_software = MagicMock(CVEs=["CVE-2023-1234"])
        mock_get_info.return_value = [MagicMock(ExploitDBID=12345, Link=exploit_link)]

        GetExploitsFromArray([mock_vuln_software], mock_log, mock_console, mock_console2, "host")

        mock_log.logger.assert_called_with("error", f"Connection error raised while trying to fetch: {exploit_link}")